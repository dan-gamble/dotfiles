{"id":"dfca6707-0871-4055-9a42-3322e8b8bfe0","zed":"context","version":"0.4.0","text":"```tsx oka-app/app/routes/app/product-groups/$id.tsx\nimport { randomUUID } from \"node:crypto\";\nimport { validationError } from \"@rvf/react-router\";\nimport { Page } from \"@shopify/polaris\";\nimport { data } from \"react-router\";\nimport { Form } from \"~/components/Form\";\nimport {\n\tProductGroupItemsProvider,\n\ttype SelectedItem,\n} from \"~/context/ProductGroupItemsContext\";\nimport { useToasts } from \"~/hooks/use-toasts\";\nimport {\n\tcreateGlobalProductGroup,\n\tgetGlobalProductGroupById,\n\tupdateGlobalProductGroup,\n} from \"~/models/GlobalProductGroup.server\";\nimport { createEmptyPrice } from \"~/models/Price.server\";\nimport { createEmptyProductGroup } from \"~/models/ProductGroup.server\";\nimport { toast } from \"~/utils/helpers/toast\";\nimport {\n\ttype GlobalProductGroupData,\n\tGlobalProductGroupValidator,\n} from \"~/validators/GlobalProductGroupValidator\";\nimport type { Route } from \"./+types/$id\";\nimport { GlobalProductGroupForm } from \"./components/GlobalProductGroupForm\";\n\nexport async function loader({\n\tcontext,\n\tparams,\n\trequest,\n}: Route.LoaderArgs): Promise<{\n\tglobalProductGroup: GlobalProductGroupData;\n\tselectedItems: SelectedItem[];\n}> {\n\tif (params.id === \"new\") {\n\t\tconst productGroup = createEmptyProductGroup();\n\t\tconst globalProductGroupId = randomUUID();\n\n\t\treturn {\n\t\t\tglobalProductGroup: {\n\t\t\t\tid: globalProductGroupId,\n\t\t\t\ttitle: \"\",\n\t\t\t\tproductGroupId: productGroup.id,\n\t\t\t\tproductGroup: {\n\t\t\t\t\t...productGroup,\n\t\t\t\t\tprice: createEmptyPrice(\"GBP\", \"ProductGroup\", productGroup.id),\n\t\t\t\t\tproductGroupItems: [],\n\t\t\t\t},\n\t\t\t},\n\t\t\tselectedItems: [],\n\t\t};\n\t}\n\n\tconst { admin } = await context.shopify.authenticate.admin(request);\n\n\tconst globalProductGroup = await getGlobalProductGroupById({\n\t\tdb: context.db,\n\t\tgraphql: admin.graphql,\n\t\tid: params.id,\n\t});\n\n\tif (!globalProductGroup) {\n\t\tthrow new Response(null, {\n\t\t\tstatus: 404,\n\t\t\tstatusText: \"Unable to find product group\",\n\t\t});\n\t}\n\n\treturn {\n\t\tglobalProductGroup: globalProductGroup.databaseData,\n\t\tselectedItems: globalProductGroup.selectedItems,\n\t};\n}\n\nexport default function ProductGroupsShow({\n\tloaderData,\n\tparams,\n}: Route.ComponentProps) {\n\tuseToasts();\n\n\treturn (\n\t\t<ProductGroupItemsProvider\n\t\t\tinitialState={{\n\t\t\t\tselectedItems: loaderData.selectedItems,\n\t\t\t}}\n\t\t>\n\t\t\t<Page\n\t\t\t\ttitle={loaderData.globalProductGroup.title || \"Product group\"}\n\t\t\t\tbackAction={{\n\t\t\t\t\turl: \"/app/product-groups\",\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<Form\n\t\t\t\t\tvalidator={GlobalProductGroupValidator}\n\t\t\t\t\tdefaultValues={loaderData.globalProductGroup}\n\t\t\t\t>\n\t\t\t\t\t<GlobalProductGroupForm id={params.id} />\n\t\t\t\t</Form>\n\t\t\t</Page>\n\t\t</ProductGroupItemsProvider>\n\t);\n}\n\nexport async function action({ context, params, request }: Route.ActionArgs) {\n\tconst { admin, redirect } = await context.shopify.authenticate.admin(request);\n\tconst validator = GlobalProductGroupValidator;\n\n\t// TODO: When submitting a form with the `submitSource` of \"post\" it has type errors of expected number but got string. Can we change the schema to allow or do we need to use `submitSource` of state?\n\n\t/**\n\t * The insert schema's should just be scoped to the tables themselves, not the nested version we\n\t * currently have The validators should almost be route specific or domain specific. i.e. this is\n\t * the create global product group validator. That is different to creating a table We can do\n\t * minimum: z.coerce.number() in the createInsertSchema function so we can accept strings with\n\t * the \"post\" submitSource We need to transaction a global product group creation\n\t */\n\n\tconst validationResult = await validator.validate(await request.formData());\n\tif (validationResult.error) {\n\t\treturn validationError(validationResult.error);\n\t}\n\n\tif (params.id === \"new\") {\n\t\tconst globalProductGroup = await createGlobalProductGroup({\n\t\t\tdb: context.db,\n\t\t\tdata: validationResult.data,\n\t\t});\n\n\t\tif (!globalProductGroup) {\n\t\t\treturn data(\n\t\t\t\ttoast(\"There was an error creating the product group\", {\n\t\t\t\t\tisError: true,\n\t\t\t\t}),\n\t\t\t\t{ status: 500 },\n\t\t\t);\n\t\t}\n\n\t\treturn redirect(`/app/product-groups/${validationResult.data.id}`);\n\t}\n\tif (params.id) {\n\t\tconst globalProductGroup = await updateGlobalProductGroup({\n\t\t\tdata: validationResult.data,\n\t\t\tdb: context.db,\n\t\t\tid: params.id,\n\t\t});\n\n\t\tif (!globalProductGroup) {\n\t\t\treturn data(\n\t\t\t\ttoast(\"There was an error update the product group\", {\n\t\t\t\t\tisError: true,\n\t\t\t\t}),\n\t\t\t\t{ status: 500 },\n\t\t\t);\n\t\t}\n\n\t\treturn toast(\"Product group updated\");\n\t}\n\n\treturn data(\n\t\ttoast(\"Product group not found\", {\n\t\t\tisError: true,\n\t\t}),\n\t\t{ status: 500 },\n\t);\n}\n```\n\nThe `$id` file is used for creating and editing product groups once they are made. The structure of a product group can be seen by looking at the schemas here \noka-app/app/database/schema\n```ts oka-app/app/database/schema/global-product-groups.ts\nimport { sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { timestamps, uuid } from \"../utils\";\nimport { productGroups } from \"./product-groups\";\n\nexport const globalProductGroups = sqliteTable(\"global_product_groups\", {\n\tid: uuid(),\n\n\ttitle: text().notNull(),\n\n\tproductGroupId: text()\n\t\t.references(() => productGroups.id, { onDelete: \"cascade\" })\n\t\t.notNull(),\n\n\t...timestamps,\n});\n\nexport const globalProductGroupsInsertSchema =\n\tcreateInsertSchema(globalProductGroups);\n```\n\n```ts oka-app/app/database/schema/made-to-order-configuration-product-groups.ts\nimport { primaryKey, sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport { timestamps } from \"../utils\";\nimport { madeToOrderConfigurations } from \"./made-to-order-configurations\";\nimport { productGroups } from \"./product-groups\";\n\nexport const madeToOrderConfigurationProductGroups = sqliteTable(\n\t\"made_to_order_configuration_product_groups\",\n\t{\n\t\tmadeToOrderConfigurationId: text()\n\t\t\t.references(() => madeToOrderConfigurations.id)\n\t\t\t.notNull(),\n\t\tproductGroupId: text()\n\t\t\t.references(() => productGroups.id)\n\t\t\t.notNull(),\n\t\tdependentProductGroupId: text().references(() => productGroups.id),\n\n\t\t...timestamps,\n\t},\n\t(table) => {\n\t\treturn {\n\t\t\tpk: primaryKey({\n\t\t\t\tcolumns: [table.madeToOrderConfigurationId, table.productGroupId],\n\t\t\t}),\n\t\t};\n\t},\n);\n```\n\n```ts oka-app/app/database/schema/made-to-order-configurations.ts\nimport { sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport type { ShopifyGid } from \"../../utils/zod/shopify\";\nimport { timestamps, uuid } from \"../utils\";\n\nexport const madeToOrderConfigurations = sqliteTable(\n\t\"made_to_order_configurations\",\n\t{\n\t\tid: uuid(),\n\t\ttitle: text().notNull(),\n\t\tsku: text().notNull(),\n\n\t\tproductId: text().notNull().$type<ShopifyGid<\"Product\">>().unique(),\n\n\t\t...timestamps,\n\t},\n);\n```\n\n```ts oka-app/app/database/schema/prices.ts\nimport { real, sqliteTable, text, unique } from \"drizzle-orm/sqlite-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\nimport { timestamps, uuid } from \"../utils\";\nimport { productGroupItems } from \"./product-group-items\";\n\nexport const PriceableTypes = [\"ProductGroup\", \"ProductGroupItem\"] as const;\nexport type PriceableType = (typeof PriceableTypes)[number];\n\nexport const prices = sqliteTable(\n\t\"prices\",\n\t{\n\t\tid: uuid(),\n\n\t\tamount: real().notNull(),\n\t\tcurrencyCode: text().notNull(),\n\n\t\tpriceableType: text({\n\t\t\tenum: PriceableTypes,\n\t\t}).notNull(),\n\t\tpriceableId: text().notNull(),\n\t\tproductGroupItemId: text().references(() => productGroupItems.id),\n\t\tdependentProductGroupItemId: text().references(() => productGroupItems.id),\n\n\t\t...timestamps,\n\t},\n\t(table) => [\n\t\tunique(\"idx_prices_unique_combination\").on(\n\t\t\ttable.priceableType,\n\t\t\ttable.priceableId,\n\t\t\ttable.currencyCode,\n\t\t\ttable.productGroupItemId,\n\t\t\ttable.dependentProductGroupItemId,\n\t\t),\n\t],\n);\n\nexport const pricesInsertSchema = createInsertSchema(prices, {\n\tamount: z.coerce.number(),\n});\nexport type PricesInsert = z.infer<typeof pricesInsertSchema>;\n```\n\n```ts oka-app/app/database/schema/product-group-items.ts\nimport { sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { type ShopifyGid, shopifyGid } from \"../../utils/zod/shopify\";\nimport { timestamps, uuid } from \"../utils\";\nimport { productGroups } from \"./product-groups\";\n\nexport const productGroupItems = sqliteTable(\"product_group_items\", {\n\tid: uuid(),\n\n\tproductId: text().notNull().$type<ShopifyGid<\"Product\">>(),\n\tvariantId: text().notNull().$type<ShopifyGid<\"ProductVariant\">>(),\n\n\tproductGroupId: text()\n\t\t.references(() => productGroups.id, { onDelete: \"cascade\" })\n\t\t.notNull(),\n\n\t...timestamps,\n});\n\nexport const productGroupItemsInsertSchema = createInsertSchema(\n\tproductGroupItems,\n\t{\n\t\tproductId: shopifyGid(\"Product\"),\n\t\tvariantId: shopifyGid(\"ProductVariant\"),\n\t},\n);\n```\n\n```ts oka-app/app/database/schema/product-groups.ts\nimport { integer, sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { type ZodRawShape, z } from \"zod\";\nimport { timestamps, uuid } from \"../utils\";\n\nexport const productGroups = sqliteTable(\"product_groups\", {\n\tid: uuid(),\n\ttitle: text().notNull(),\n\n\tminimumNumberOfChoices: integer().default(1).notNull(),\n\tmaximumNumberOfChoices: integer().default(1).notNull(),\n\n\t...timestamps,\n});\n\nexport const productGroupsInsertSchema = createInsertSchema(productGroups, {\n\tminimumNumberOfChoices: z.coerce.number().min(0),\n\tmaximumNumberOfChoices: z.coerce.number().min(1),\n});\n\nexport type ProductGroupsInsert = z.infer<typeof productGroupsInsertSchema>;\n\nexport function refineProductGroupsInsertSchema<T extends ZodRawShape>(\n\tschema: T,\n) {\n\treturn productGroupsInsertSchema.extend(schema).superRefine((data, ctx) => {\n\t\tif (\n\t\t\ttypeof data?.minimumNumberOfChoices !== \"undefined\" &&\n\t\t\ttypeof data?.maximumNumberOfChoices !== \"undefined\"\n\t\t) {\n\t\t\tif (data.minimumNumberOfChoices > data.maximumNumberOfChoices) {\n\t\t\t\tctx.addIssue({\n\t\t\t\t\tcode: z.ZodIssueCode.custom,\n\t\t\t\t\tmessage: \"\",\n\t\t\t\t});\n\n\t\t\t\treturn z.NEVER;\n\t\t\t}\n\t\t}\n\t});\n}\n```\n\n```ts oka-app/app/database/schema/shops.ts\nimport { integer, sqliteTable, text } from \"drizzle-orm/sqlite-core\";\n\nexport const shops = sqliteTable(\"shops\", {\n\tid: integer(\"id\").primaryKey({ autoIncrement: true }),\n\tshopDomain: text(\"shop_domain\").unique().notNull(),\n\n\tappId: text(\"app_id\").notNull(),\n});\n```\n\n\n\nWhen a product group is updated, it can have product group items added or removed. Can you help me update my `updateGlobalProductGroups` file in to add/update/remove items as appropriate, please? \n```ts oka-app/app/models/GlobalProductGroup.server.ts\nimport { parseGid } from \"@shopify/admin-graphql-api-utilities\";\nimport {\n\ttype SQL,\n\tand,\n\tasc,\n\tdesc,\n\teq,\n\tinArray,\n\tisNull,\n\tlike,\n\tor,\n} from \"drizzle-orm\";\nimport type { SelectedItem } from \"~/context/ProductGroupItemsContext\";\nimport { globalProductGroups } from \"~/database/schema/global-product-groups\";\nimport { prices } from \"~/database/schema/prices\";\nimport { productGroupItems } from \"~/database/schema/product-group-items\";\nimport { productGroups } from \"~/database/schema/product-groups\";\nimport type { getSellingPlanGroupsQueryVariables } from \"~/routes/app/product-groups/utils\";\nimport { makeRequest } from \"~/server/utils/graphql.server\";\nimport type { GlobalProductGroupData } from \"~/validators/GlobalProductGroupValidator\";\nimport type { Database } from \"../../load-context/database\";\nimport type { ShopifyGraphQLClient } from \"../../load-context/shopify\";\n\ntype DatabaseData = Awaited<\n\tReturnType<typeof fetchGlobalProductGroupsFromDatabase>\n>;\n\nexport async function getGlobalProductGroupsCount({ db }: { db: Database }) {\n\treturn db.$count(globalProductGroups);\n}\n\nexport async function getGlobalProductGroups({\n\tdb,\n\tsortKey,\n\treverse,\n\tpage,\n\tperPage,\n\tquery,\n}: ReturnType<typeof getSellingPlanGroupsQueryVariables> & {\n\tdb: Database;\n}) {\n\tconst data = await fetchGlobalProductGroupsFromDatabase(db, {\n\t\tsortKey,\n\t\treverse,\n\t\tpage,\n\t\tperPage,\n\t\tquery,\n\t});\n\tif (data.length === 0) return [];\n\n\treturn groupProductGroupsById(data)\n\t\t.map((datum) => transformDatabaseData(datum))\n\t\t.filter(Boolean);\n}\n\nexport async function getGlobalProductGroupById({\n\tdb,\n\tgraphql,\n\tid,\n}: { db: Database; graphql: ShopifyGraphQLClient; id: string }): Promise<{\n\tdatabaseData: GlobalProductGroupData;\n\tselectedItems: SelectedItem[];\n} | null> {\n\tconst databaseData = await getGlobalProductGroupFromTheDatabase(db, id);\n\tif (!databaseData) return null;\n\n\tconst productsResponse = await makeRequest(\n\t\tgraphql,\n\t\t`#graphql\n\t\tquery GlobalProductGroupProducts ($count: Int!, $query: String!) {\n\t\t\tproducts(first: $count, query: $query) {\n\t\t\t\tnodes {\n\t\t\t\t\tid\n\t\t\t\t\ttitle\n\t\t\t\t\tmedia (first: 1, query: \"media_type:IMAGE\") {\n\t\t\t\t\t\tnodes {\n\t\t\t\t\t\t\tpreview {\n\t\t\t\t\t\t\t\timage {\n\t\t\t\t\t\t\t\t\turl(transform: {maxWidth: 60, maxHeight: 60, scale: 2})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvariants(first: 100) {\n\t\t\t\t\t\tnodes {\n\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\ttitle\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`,\n\t\t{\n\t\t\tvariables: {\n\t\t\t\tcount: databaseData.productGroup.productGroupItems.length,\n\t\t\t\tquery: databaseData.productGroup.productGroupItems\n\t\t\t\t\t.map((item) => `(id:${parseGid(item.productId)})`)\n\t\t\t\t\t.join(\" OR \"),\n\t\t\t},\n\t\t},\n\t);\n\n\tconst nodes = productsResponse.data?.products?.nodes;\n\tif (!nodes) return null;\n\n\tconst selectedItems: SelectedItem[] =\n\t\tdatabaseData.productGroup.productGroupItems.map((item) => {\n\t\t\tconst productFromShopify = nodes.find(\n\t\t\t\t(node) => node.id === item.productId,\n\t\t\t);\n\t\t\tif (!productFromShopify)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Unable to determine selected items because ${item.productId} isn't in the shopify data`,\n\t\t\t\t);\n\n\t\t\tconst variant = productFromShopify.variants.nodes.find(\n\t\t\t\t(variant) => variant.id === item.variantId,\n\t\t\t);\n\t\t\tif (!variant)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Unable to determine selected items because ${item.variantId} isn't in the shopify data`,\n\t\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tproductId: item.productId,\n\t\t\t\tvariantId: item.variantId,\n\t\t\t\ttitle: productFromShopify.title,\n\t\t\t\tvariantTitle: variant.title,\n\t\t\t\timageUrl: productFromShopify.media.nodes?.[0]?.preview?.image?.url,\n\t\t\t};\n\t\t});\n\n\treturn { databaseData, selectedItems };\n}\n\nexport async function createGlobalProductGroup({\n\tdata,\n\tdb,\n}: {\n\tdata: GlobalProductGroupData;\n\tdb: Database;\n}) {\n\tconst batchResponse = await db.batch([\n\t\tdb.insert(productGroups).values({\n\t\t\tid: data.productGroup.id,\n\t\t\ttitle: data.productGroup.title,\n\t\t\tminimumNumberOfChoices: data.productGroup.minimumNumberOfChoices,\n\t\t\tmaximumNumberOfChoices: data.productGroup.maximumNumberOfChoices,\n\t\t}),\n\t\tdb.insert(prices).values({\n\t\t\tid: data.productGroup.price.id,\n\t\t\tamount: data.productGroup.price.amount,\n\t\t\tcurrencyCode: data.productGroup.price.currencyCode,\n\t\t\tpriceableType: \"ProductGroup\",\n\t\t\tpriceableId: data.productGroup.id,\n\t\t}),\n\t\tdb.insert(globalProductGroups).values({\n\t\t\tid: data.id,\n\t\t\ttitle: data.title,\n\t\t\tproductGroupId: data.productGroup.id,\n\t\t}),\n\t\t...data.productGroup.productGroupItems.flatMap((item) => {\n\t\t\treturn [\n\t\t\t\tdb.insert(productGroupItems).values({\n\t\t\t\t\tid: item.id,\n\t\t\t\t\tproductId: item.productId,\n\t\t\t\t\tvariantId: item.variantId,\n\t\t\t\t\tproductGroupId: data.productGroup.id,\n\t\t\t\t}),\n\t\t\t\tdb.insert(prices).values({\n\t\t\t\t\tid: item.price.id,\n\t\t\t\t\tamount: item.price.amount,\n\t\t\t\t\tcurrencyCode: item.price.currencyCode,\n\t\t\t\t\tpriceableType: \"ProductGroupItem\",\n\t\t\t\t\tpriceableId: item.id,\n\t\t\t\t}),\n\t\t\t];\n\t\t}),\n\t]);\n\n\treturn data;\n}\n\nexport async function updateGlobalProductGroup({\n\tdata,\n\tdb,\n\tid,\n}: {\n\tdata: GlobalProductGroupData;\n\tdb: Database;\n\tid: string;\n}) {\n\tawait db.batch([\n\t\tdb\n\t\t\t.update(globalProductGroups)\n\t\t\t.set({\n\t\t\t\ttitle: data.title,\n\t\t\t})\n\t\t\t.where(eq(globalProductGroups.id, id)),\n\t\tdb\n\t\t\t.update(productGroups)\n\t\t\t.set({\n\t\t\t\ttitle: data.productGroup.title,\n\t\t\t\tminimumNumberOfChoices: data.productGroup.minimumNumberOfChoices,\n\t\t\t\tmaximumNumberOfChoices: data.productGroup.maximumNumberOfChoices,\n\t\t\t})\n\t\t\t.where(eq(productGroups.id, data.productGroup.id)),\n\t\tdb\n\t\t\t.update(prices)\n\t\t\t.set({\n\t\t\t\tamount: data.productGroup.price.amount,\n\t\t\t\tcurrencyCode: data.productGroup.price.currencyCode,\n\t\t\t})\n\t\t\t.where(eq(prices.id, data.productGroup.price.id)),\n\t\t...data.productGroup.productGroupItems.flatMap((item) => {\n\t\t\treturn [\n\t\t\t\tdb\n\t\t\t\t\t.update(productGroupItems)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tproductId: item.productId,\n\t\t\t\t\t\tvariantId: item.variantId,\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(productGroupItems.id, item.id)),\n\t\t\t\tdb\n\t\t\t\t\t.update(prices)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tamount: item.price.amount,\n\t\t\t\t\t\tcurrencyCode: item.price.currencyCode,\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(prices.id, item.price.id)),\n\t\t\t];\n\t\t}),\n\t]);\n\n\treturn data;\n}\n\nexport async function deleteGlobalProductGroups({\n\tdb,\n\tids,\n}: { db: Database; ids: string[] }) {\n\tconst now = new Date();\n\n\treturn db\n\t\t.update(globalProductGroups)\n\t\t.set({\n\t\t\tdeletedAt: now\n\t\t\t\t.toLocaleString(\"en-GB\", {\n\t\t\t\t\tyear: \"numeric\",\n\t\t\t\t\tmonth: \"2-digit\",\n\t\t\t\t\tday: \"2-digit\",\n\t\t\t\t\thour: \"2-digit\",\n\t\t\t\t\tminute: \"2-digit\",\n\t\t\t\t\tsecond: \"2-digit\",\n\t\t\t\t\thour12: false,\n\t\t\t\t})\n\t\t\t\t.replace(/(\\d+)\\/(\\d+)\\/(\\d+),/, \"$3-$2-$1\"),\n\t\t})\n\t\t.where(inArray(globalProductGroups.id, ids))\n\t\t.returning();\n}\n\nasync function getGlobalProductGroupFromTheDatabase(db: Database, id: string) {\n\treturn transformDatabaseData(\n\t\tawait fetchGlobalProductGroupsFromDatabase(db, { id }),\n\t);\n}\n\nasync function fetchGlobalProductGroupsFromDatabase(\n\tdb: Database,\n\t{\n\t\tid,\n\t\tsortKey,\n\t\treverse,\n\t\tpage,\n\t\tperPage,\n\t\tquery,\n\t}: Partial<ReturnType<typeof getSellingPlanGroupsQueryVariables>> & {\n\t\tid?: string;\n\t} = {},\n) {\n\tconst filters: SQL[] = [];\n\tfilters.push(isNull(globalProductGroups.deletedAt));\n\n\tlet subquery = db\n\t\t.select({\n\t\t\tid: globalProductGroups.id,\n\t\t})\n\t\t.from(globalProductGroups)\n\t\t.$dynamic();\n\n\tif (sortKey) {\n\t\tconst direction = reverse ? asc : desc;\n\n\t\tswitch (sortKey) {\n\t\t\tcase \"CREATED_AT\":\n\t\t\t\tsubquery = subquery.orderBy(direction(globalProductGroups.createdAt));\n\t\t\t\tbreak;\n\t\t\tcase \"UPDATED_AT\":\n\t\t\t\tsubquery = subquery.orderBy(direction(globalProductGroups.updatedAt));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (query) {\n\t\tfilters.push(like(globalProductGroups.title, `%${query}%`));\n\t}\n\n\tif (perPage) {\n\t\tsubquery = subquery.limit(perPage);\n\t}\n\n\tif (page && perPage) {\n\t\tsubquery = subquery.offset((page - 1) * perPage);\n\t}\n\n\tsubquery = subquery.where(and(...filters));\n\n\tif (id) {\n\t\tsubquery = subquery.where(eq(globalProductGroups.id, id));\n\t}\n\n\treturn db\n\t\t.selectDistinct({\n\t\t\tglobalProductGroup: globalProductGroups,\n\t\t\tproductGroup: productGroups,\n\t\t\titems: productGroupItems,\n\t\t\tprices: prices,\n\t\t})\n\t\t.from(globalProductGroups)\n\t\t.innerJoin(\n\t\t\tproductGroups,\n\t\t\teq(productGroups.id, globalProductGroups.productGroupId),\n\t\t)\n\t\t.leftJoin(\n\t\t\tproductGroupItems,\n\t\t\teq(productGroupItems.productGroupId, globalProductGroups.productGroupId),\n\t\t)\n\t\t.leftJoin(\n\t\t\tprices,\n\t\t\tor(\n\t\t\t\tand(\n\t\t\t\t\teq(prices.priceableId, globalProductGroups.productGroupId),\n\t\t\t\t\teq(prices.priceableType, \"ProductGroup\"),\n\t\t\t\t),\n\t\t\t\tand(\n\t\t\t\t\teq(prices.priceableId, productGroupItems.id),\n\t\t\t\t\teq(prices.priceableType, \"ProductGroupItem\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\t.where(inArray(globalProductGroups.id, subquery))\n\t\t.orderBy(\n\t\t\tglobalProductGroups.createdAt,\n\t\t\tproductGroups.createdAt,\n\t\t\tproductGroupItems.createdAt,\n\t\t\tprices.createdAt,\n\t\t);\n}\n\nfunction transformDatabaseData(data: DatabaseData) {\n\tif (!data.length) {\n\t\treturn null;\n\t}\n\n\tconst firstRow = data[0];\n\n\tif (!firstRow.globalProductGroup || !firstRow.productGroup) {\n\t\treturn null;\n\t}\n\n\tconst uniqueItems = Array.from(\n\t\tnew Map(\n\t\t\tdata\n\t\t\t\t.map((row) => row.items)\n\t\t\t\t.filter(\n\t\t\t\t\t(item): item is typeof productGroupItems.$inferSelect =>\n\t\t\t\t\t\titem !== null && typeof item === \"object\" && \"id\" in item,\n\t\t\t\t)\n\t\t\t\t.map((item) => [item.id, item]),\n\t\t).values(),\n\t);\n\tconst priceRows = data\n\t\t.map((row) => row.prices)\n\t\t.filter(\n\t\t\t(item): item is typeof prices.$inferSelect =>\n\t\t\t\titem !== null && typeof item === \"object\" && \"id\" in item,\n\t\t);\n\n\tconst productGroupPrice = priceRows.find(\n\t\t(priceRow) =>\n\t\t\tpriceRow.priceableId === firstRow.productGroup.id &&\n\t\t\tpriceRow.priceableType === \"ProductGroup\",\n\t);\n\tif (!productGroupPrice)\n\t\tthrow new Error(`Unable to find price for ${firstRow.productGroup.id}`);\n\n\tconst globalProductGroup = {\n\t\t...firstRow.globalProductGroup,\n\t\tproductGroup: {\n\t\t\t...firstRow.productGroup,\n\t\t\tprice: productGroupPrice,\n\t\t\titems: uniqueItems.map((item) => {\n\t\t\t\tconst price = priceRows.find(\n\t\t\t\t\t(priceRow) =>\n\t\t\t\t\t\tpriceRow.priceableId === item.id &&\n\t\t\t\t\t\tpriceRow.priceableType === \"ProductGroupItem\",\n\t\t\t\t);\n\t\t\t\tif (!price) throw new Error(`Unable to find price for ${item.id}`);\n\n\t\t\t\treturn {\n\t\t\t\t\t...item,\n\t\t\t\t\tprice,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t};\n\n\treturn {\n\t\tid: globalProductGroup.id,\n\t\ttitle: globalProductGroup.title,\n\t\tproductGroupId: globalProductGroup.productGroupId,\n\t\tproductGroup: {\n\t\t\tid: globalProductGroup.productGroup.id,\n\t\t\ttitle: globalProductGroup.productGroup.title,\n\t\t\tprice: {\n\t\t\t\tid: globalProductGroup.productGroup.price.id,\n\t\t\t\tamount: globalProductGroup.productGroup.price.amount,\n\t\t\t\tcurrencyCode: globalProductGroup.productGroup.price.currencyCode,\n\t\t\t\tpriceableType: globalProductGroup.productGroup.price.priceableType,\n\t\t\t\tpriceableId: globalProductGroup.productGroup.price.priceableId,\n\t\t\t},\n\t\t\tminimumNumberOfChoices:\n\t\t\t\tglobalProductGroup.productGroup.minimumNumberOfChoices,\n\t\t\tmaximumNumberOfChoices:\n\t\t\t\tglobalProductGroup.productGroup.maximumNumberOfChoices,\n\t\t\tproductGroupItems: globalProductGroup.productGroup.items.map((item) => {\n\t\t\t\treturn {\n\t\t\t\t\tid: item.id,\n\t\t\t\t\tproductId: item.productId,\n\t\t\t\t\tvariantId: item.variantId,\n\t\t\t\t\tproductGroupId: item.productGroupId,\n\t\t\t\t\tprice: {\n\t\t\t\t\t\tid: item.price.id,\n\t\t\t\t\t\tamount: item.price.amount,\n\t\t\t\t\t\tcurrencyCode: item.price.currencyCode,\n\t\t\t\t\t\tpriceableType: item.price.priceableType,\n\t\t\t\t\t\tpriceableId: item.price.priceableId,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t\tupdatedAt: globalProductGroup.updatedAt,\n\t} as const satisfies GlobalProductGroupData;\n}\n\nfunction groupProductGroupsById(data: DatabaseData): DatabaseData[] {\n\tconst productGroups = data.reduce<Map<string, DatabaseData>>(\n\t\t(groups, datum) => {\n\t\t\tconst group = groups.get(datum.globalProductGroup.id);\n\t\t\tif (!group) {\n\t\t\t\tgroups.set(datum.globalProductGroup.id, [datum]);\n\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\t\tgroup.push(datum);\n\n\t\t\treturn groups;\n\t\t},\n\t\tnew Map<string, DatabaseData>(),\n\t);\n\n\treturn Array.from(productGroups.values());\n}\n```\n\n\n\nI'll help you update the `updateGlobalProductGroup` function to handle adding, updating, and removing product group items. Here's how we can modify it:\n\n```typescript\nexport async function updateGlobalProductGroup({\n  data,\n  db,\n  id,\n}: {\n  data: GlobalProductGroupData;\n  db: Database;\n  id: string;\n}) {\n  // First get existing product group items\n  const existingItems = await db\n    .select()\n    .from(productGroupItems)\n    .where(eq(productGroupItems.productGroupId, data.productGroup.id));\n\n  // Create sets of item IDs for comparison\n  const existingItemIds = new Set(existingItems.map(item => item.id));\n  const newItemIds = new Set(data.productGroup.productGroupItems.map(item => item.id));\n\n  // Find items to delete, add, and update\n  const itemsToDelete = existingItems.filter(item => !newItemIds.has(item.id));\n  const itemsToAdd = data.productGroup.productGroupItems.filter(item => !existingItemIds.has(item.id));\n  const itemsToUpdate = data.productGroup.productGroupItems.filter(item => existingItemIds.has(item.id));\n\n  // Build all database operations\n  const operations = [\n    // Update global product group\n    db\n      .update(globalProductGroups)\n      .set({\n        title: data.title,\n      })\n      .where(eq(globalProductGroups.id, id)),\n\n    // Update product group\n    db\n      .update(productGroups)\n      .set({\n        title: data.productGroup.title,\n        minimumNumberOfChoices: data.productGroup.minimumNumberOfChoices,\n        maximumNumberOfChoices: data.productGroup.maximumNumberOfChoices,\n      })\n      .where(eq(productGroups.id, data.productGroup.id)),\n\n    // Update product group price\n    db\n      .update(prices)\n      .set({\n        amount: data.productGroup.price.amount,\n        currencyCode: data.productGroup.price.currencyCode,\n      })\n      .where(eq(prices.id, data.productGroup.price.id)),\n\n    // Delete removed items and their prices\n    ...itemsToDelete.flatMap(item => [\n      db.delete(productGroupItems).where(eq(productGroupItems.id, item.id)),\n      db.delete(prices).where(\n        and(\n          eq(prices.priceableId, item.id),\n          eq(prices.priceableType, \"ProductGroupItem\")\n        )\n      ),\n    ]),\n\n    // Add new items and their prices\n    ...itemsToAdd.flatMap(item => [\n      db.insert(productGroupItems).values({\n        id: item.id,\n        productId: item.productId,\n        variantId: item.variantId,\n        productGroupId: data.productGroup.id,\n      }),\n      db.insert(prices).values({\n        id: item.price.id,\n        amount: item.price.amount,\n        currencyCode: item.price.currencyCode,\n        priceableType: \"ProductGroupItem\",\n        priceableId: item.id,\n      }),\n    ]),\n\n    // Update existing items and their prices\n    ...itemsToUpdate.flatMap(item => [\n      db\n        .update(productGroupItems)\n        .set({\n          productId: item.productId,\n          variantId: item.variantId,\n        })\n        .where(eq(productGroupItems.id, item.id)),\n      db\n        .update(prices)\n        .set({\n          amount: item.price.amount,\n          currencyCode: item.price.currencyCode,\n        })\n        .where(eq(prices.id, item.price.id)),\n    ]),\n  ];\n\n  // Execute all operations in a batch\n  await db.batch(operations);\n\n  return data;\n}\n```\n\nThis updated version:\n\n1. Fetches existing product group items first\n2. Compares existing items with new items to determine what needs to be:\n   - Deleted (items that exist in database but not in new data)\n   - Added (items that are in new data but not in database)\n   - Updated (items that exist in both)\n3. Creates appropriate database operations for each case:\n   - Deletes removed items and their associated prices\n   - Adds new items with their prices\n   - Updates existing items and their prices\n4. Maintains the existing updates to the global product group, product group, and main price\n5. Executes all operations in a single batch\n\nThis approach ensures that all product group items are properly synchronized with the database while maintaining referential integrity and handling all associated prices.\nThis is giving me a TS error. What should the type be for the `operations` array?\nThe `operations` array should be typed as a DrizzleORM batch operation array. Here's the corrected typing:\n\n```typescript\nimport type { SQLiteTableFn, SqliteTransaction } from \"drizzle-orm/sqlite-core\";\n\nexport async function updateGlobalProductGroup({\n  data,\n  db,\n  id,\n}: {\n  data: GlobalProductGroupData;\n  db: Database;\n  id: string;\n}) {\n  const existingItems = await db\n    .select()\n    .from(productGroupItems)\n    .where(eq(productGroupItems.productGroupId, data.productGroup.id));\n\n  const existingItemIds = new Set(existingItems.map(item => item.id));\n  const newItemIds = new Set(data.productGroup.productGroupItems.map(item => item.id));\n\n  const itemsToDelete = existingItems.filter(item => !newItemIds.has(item.id));\n  const itemsToAdd = data.productGroup.productGroupItems.filter(item => !existingItemIds.has(item.id));\n  const itemsToUpdate = data.productGroup.productGroupItems.filter(item => existingItemIds.has(item.id));\n\n  const operations: Parameters<typeof db.batch>[0] = [\n    // Rest of the code remains the same...\n  ];\n\n  await db.batch(operations);\n\n  return data;\n}\n```\n\nAlternatively, you could use:\n\n```typescript\nconst operations: ReturnType<SQLiteTableFn<any>>[] = [\n  // ... operations\n];\n```\n\nOr the most specific type:\n\n```typescript\nconst operations: (\n  | ReturnType<typeof db.update>\n  | ReturnType<typeof db.insert>\n  | ReturnType<typeof db.delete>\n)[] = [\n  // ... operations\n];\n```\n\nAny of these type annotations should work, with the first one (`Parameters<typeof db.batch>[0]`) being the most accurate since it exactly matches what the `batch` method expects.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":183}}},{"id":{"replica_id":0,"value":90},"start":22274,"metadata":{"role":"user","status":{"Error":"not connected"},"timestamp":{"replica_id":0,"value":184}}},{"id":{"replica_id":0,"value":91},"start":22275,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":185}}},{"id":{"replica_id":0,"value":104},"start":22276,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":186}}},{"id":{"replica_id":0,"value":105},"start":26349,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":187}}},{"id":{"replica_id":0,"value":143},"start":26431,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":188}}},{"id":{"replica_id":0,"value":144},"start":28038,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":189}}}],"summary":"Update Product Groups Items Management","slash_command_output_sections":[{"range":{"start":0,"end":4517},"icon":"File","label":"oka-app/app/routes/app/product-groups/$id.tsx","metadata":{"path":"oka-app/app/routes/app/product-groups/$id.tsx"}},{"range":{"start":4678,"end":10250},"icon":"Folder","label":"oka-app/app/database/schema","metadata":null},{"range":{"start":4706,"end":5303},"icon":"File","label":"oka-app/app/database/schema/global-product-groups.ts","metadata":{"path":"oka-app/app/database/schema/global-product-groups.ts"}},{"range":{"start":5304,"end":6152},"icon":"File","label":"oka-app/app/database/schema/made-to-order-configuration-product-groups.ts","metadata":{"path":"oka-app/app/database/schema/made-to-order-configuration-product-groups.ts"}},{"range":{"start":6153,"end":6642},"icon":"File","label":"oka-app/app/database/schema/made-to-order-configurations.ts","metadata":{"path":"oka-app/app/database/schema/made-to-order-configurations.ts"}},{"range":{"start":6643,"end":7846},"icon":"File","label":"oka-app/app/database/schema/prices.ts","metadata":{"path":"oka-app/app/database/schema/prices.ts"}},{"range":{"start":7847,"end":8697},"icon":"File","label":"oka-app/app/database/schema/product-group-items.ts","metadata":{"path":"oka-app/app/database/schema/product-group-items.ts"}},{"range":{"start":8698,"end":9938},"icon":"File","label":"oka-app/app/database/schema/product-groups.ts","metadata":{"path":"oka-app/app/database/schema/product-groups.ts"}},{"range":{"start":9939,"end":10249},"icon":"File","label":"oka-app/app/database/schema/shops.ts","metadata":{"path":"oka-app/app/database/schema/shops.ts"}},{"range":{"start":10449,"end":22273},"icon":"File","label":"oka-app/app/models/GlobalProductGroup.server.ts","metadata":{"path":"oka-app/app/models/GlobalProductGroup.server.ts"}}]}